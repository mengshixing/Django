#struct模块用来解决bytes和其他二进制数据类型的转换。
#b'str'表示字节,字节数组==二进制str

#无符号32位二进制可表示最大为,即32位1,4294967295
n=10240099
print (bin(n))#0b  1001 1100  0100 0000  0110 0011
#&  按位与运算符:参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0
#转换为4个字节

#>> 右移动运算符：把">>"左边的运算数的各二进位全部右移若干位，">>"右边的数指定移动的位数 
b1=(n&0xff000000) >> 24 #前8位
b2=(n&0xff0000) >> 16
b3=(n&0xff00) >> 8
b4=n&0xff

bs=[b1,b2,b3,b4]
print(bs)#[0, 156, 64, 99]
#ascii码表0，null 64是@ 99是c.156超出128位
print(bytes(bs))#b'\x00\x9c@c'

#struct的pack函数把任意数据类型变成bytes:
import struct
print(struct.pack('>I', 10240099))#b'\x00\x9c@c'
#>表示字节顺序是big-endian，也就是网络序，I表示4字节无符号整数。
#网络传输一般采用大端序，也被称之为网络字节序，或网络序，
# 即先发送高字节数据再发送低字节数据
# （如：四个字节由高位向低位用0-31标示后，将首先发送0-7位第一字节，在发送8-15第二字节，以此下去）。
# IP协议中定义大端为网络字节序

#unpack把bytes变成相应的数据类型：
print(struct.unpack('>IH', b'\xf0\xf0\xf0\xf0\x80\x80'))#(4042322160, 32896)
#I：4字节无符号整数和H：2字节无符号整数。

s = b'\x42\x4d\x38\x8c\x0a\x00\x00\x00\x00\x00\x36\x00\x00\x00\
\x28\x00\x00\x00\x80\x02\x00\x00\x68\x01\x00\x00\x01\x00\x18\x00'
print(struct.unpack('<ccIIIIIIHH', s))

#(b'B', b'M', 691256, 0, 54, 40, 640, 360, 1, 24)
# 两个字节：'BM'表示Windows位图，'BA'表示OS/2位图； 
# 一个4字节整数：表示位图大小；
# 一个4字节整数：保留位，始终为0；
# 一个4字节整数：实际图像的偏移量； 
# 一个4字节整数：Header的字节数； 
# 一个4字节整数：图像宽度；
# 一个4字节整数：图像高度； 
# 一个2字节整数：始终为1；
# 一个2字节整数：颜色数。

#练习：请编写一个bmpinfo.py，可以检查任意文件是否是位图文件，如果是，打印出图片大小和颜色数。

#二进制文件,不能有errors参数
with open('bg.gif','rb') as f:
    fs=f.read(30)
    print(fs)
    fs_ls=struct.unpack('<ccIIIIIIHH', fs)
    print(fs_ls)
    print(fs_ls[0]+fs_ls[1])
    
    if(fs_ls[0]+fs_ls[1]==b'BM'):
        print('位文件')




